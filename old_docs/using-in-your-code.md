---
id: using-in-your-code
title: Using Bit Components in Your Code
permalink: docs/using-in-your-code.html
layout: docs
category: Getting Started
prev: sourcing-components.html
next: modifying-sourced-components.html
---

## import @bit (absolute path)

Any installed component in your workspace (whether it has been sourced or installed using a package manager) can be imported/required as any package, by using the `@bit` suffix.

This is how it looks:
```js
import component from '@bit.<owner>.<collection>.<namespace>.<component-name>';
```

For example, we can consume [string/left-pad](https://bit.dev/bit/utils/string/left-pad) after it's been installed as follows:

```js
import padLeft from '@bit/bit.utils.string.left-pad';
```

It's obvious that components installed using a package manager will be available for consumption like that.

The story is different for sourced components.

### Links in the `node_modules` directory

Once a component is sourced to a repository, Bit generates a link in your `node_modules` directory by the package name - pointing to the component path in your project's directory structure.  

Those links are generated by bit whenever necessary, but package managers can disrupt the links by occasionally modifying the contents of the `node_modules` directory.

If bit's links were overrun, you can explicitly run [bit link](/docs/cli-link.html) in order to recreate the link.

```bash
$ bit link
```

Better yet, you can just add `bit link` as a [postinstall script](https://docs.npmjs.com/misc/scripts) to your project's `package.json` file.

```json
{
    "name": ...
    "version": ...
    "license": ...
    "scripts": {
        "postinstall": "bit link"
    }
}
```

## import relative paths

It's really common to require other files from the same project using relative paths, as shown in the example component [string/left-pad](https://bit.dev/bit/utils/string/left-pad/code).

```js
import isString from '../is-string';
```

Relative paths (`../is-string`) couple a component to a specific project directory structure, thus making the component hard to reuse from other project structures.  
In order to make reuse in a different context possible, Bit generates `bindings` - files that allow the component dependencies to be resolved in any project structure, without delivering redundant or duplicated code.

For example, the [string/left-pad](https://bit.dev/bit/utils/string/left-pad) component, depends on the component [string/is-string](https://bit.dev/bit/utils/validation/is-string) and uses a relative import statement to call it.  
To make sure [string/is-string](https://bit.dev/bit/utils/validation/is-string) is resolved correctly, Bit creates a binding file in the correct path of the component that includes an absolute import statement to the dependency.

`is-string.js`

```js
module.exports = require('@bit/bit.examples.string.is-string');
```

> **Tip**
>
> To reduce and flatten a component file system structure, you can modify your code to use absolute paths by importing/requiring components with `@bit`.
